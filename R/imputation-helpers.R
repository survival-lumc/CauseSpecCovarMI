##********************************##
## Helpers for Imputation methods ##
##********************************##


# Set-up matrices/methods -------------------------------------------------


#' Prepare prediction matrices MICE/smcfcs
#' 
#' @param dat Dataset as generated by generate_dat()
#' 
#' @return List of prediction matrices
#' 
#' @noRd
get_predictor_mats <- function(dat) {
  
  
  
  mpred_ch1 <-  matrix(0, ncol(dat), ncol(dat),
                       dimnames = list(names(dat), 
                                       names(dat)))
  
  mpred_ch12 <- mpred_ch12_int <- mpred_smcfcs <- mpred_ch1 
  
  ## Ch1 model: MI with Z, eps (as factor) and H1(t) as covars
  mpred_ch1["X", c("Z", "ev1", "H1")] <- 1
  
  ## Ch12 model: MI with Z, eps, H1(t) & H2(t) as covars
  mpred_ch12["X", c("Z", "eps", "H1", "H2")] <- 1
  
  # Ch12 model with addition of interactions H x Z
  mpred_ch12_int["X", c("Z", "eps", "H1", "H2", "H1_Z", "H2_Z")] <- 1
  
  # smcfcs
  mpred_smcfcs["X", "Z"] <- 1
  
  # Store in a list
  mats <- list("CH1" = mpred_ch1, 
               "CH12" = mpred_ch12,
               "CH12_int" = mpred_ch12_int,
               "smcfcs" = mpred_smcfcs)
  
  return(mats)
}


# Add var_names_miss within function
set_mi_methods <- function(dat,
                           var_names_miss,
                           imp_type = "mice",
                           cont_method = "norm") {
  
  # Convert to data.table if not
  if (!("data.table" %in% class(dat))) dat <- data.table::data.table(dat)
  
  # Set up methods vector
  n_vars_miss <- length(var_names_miss)
  meths_miss <- setNames(character(n_vars_miss), var_names_miss)
  
  # Get indicators:
  ordered_ind <- sapply(dat[, ..var_names_miss], is.ordered)
  contin_ind <- sapply(dat[, ..var_names_miss], is.numeric)
  
  unordered_ind <- sapply(
    dat[, ..var_names_miss], 
    function(col) length(levels(col)) > 2 & !is.ordered(col)
  )
  
  binary_ind <- sapply(
    dat[, ..var_names_miss], 
    function(col) length(levels(col)) == 2 & !is.ordered(col)
  )
  
  # Set up methods 
  meths_miss[ordered_ind] <- "polr"
  meths_miss[contin_ind] <- cont_method
  meths_miss[unordered_ind] <- "polyreg"
  meths_miss[binary_ind] <- "logreg"
  
  # Adjust if for smcfcs
  if (imp_type == "smcfcs") {
    meths_miss[which(meths_miss == "polyreg")] <- "mlogit"
    meths_miss[which(meths_miss == "polr")] <- "podds"
  }
  
  # Make global vec
  meths <- setNames(character(ncol(dat)), names(dat))
  meths[var_names_miss] <- meths_miss
  
  return(meths)
}


# Analysis method ---------------------------------------------------------


#' @title Set-up mstate model (pre-predicting) for simulated datasets
#' 
#' @description ...
#' 
#' @inheritParams get_predictor_mats
#' 
#' @return Long cox model
#' 
#' @noRd
setup_mstate <- function(dat) {
  
  # Set up transition matrix 
  tmat <- mstate::trans.comprisk(2, c("Rel", "NRM"))
  covs <- c("X", "Z")
  
  # Long format
  dat_msprepped <- mstate::msprep(time = c(NA, "t", "t"),
                                  status = c(NA, "ev1", "ev2"), 
                                  data = dat,
                                  trans = tmat,
                                  keep = covs) 
  
  # Use longnames if ordcat
  if (length(levels(dat$X)) > 2) {
    
    # Expand covariates
    dat_expanded <- mstate::expand.covs(
      dat_msprepped, covs, append = TRUE, longnames = T
    )
    
    # Fit long cox model (both transitions)
    cox_long <- survival::coxph(Surv(time, status) ~ 
                                  Xinterm.1 + Xhigh.1 + Z.1 + # Trans == 1
                                  Xinterm.2 + Xhigh.2 + Z.2 + # Trans == 2
                                  strata(trans), # Separate baseline hazards
                                data = dat_expanded)
    
  } else {
    
    # Expand covariates
    dat_expanded <- mstate::expand.covs(
      dat_msprepped, covs, append = TRUE, longnames = F
    )
    
    # Fit long cox model (both transitions)
    cox_long <- survival::coxph(Surv(time, status) ~ 
                                  X.1 + Z.1 + # Trans == 1
                                  X.2 + Z.2 + # Trans == 2
                                  strata(trans), # Separate baseline hazards
                                data = dat_expanded)
    
  }
  
  return(cox_long)
}


# Pooling -----------------------------------------------------------------


#' Pool for different m - regression coefficietns
#' 
#' @param mods_impdats complete
#' @param n_imp Vector of m imputations to extract
#' @param analy String label to attach
#' 
#' @importFrom magrittr `%$%` 
#' 
#' @noRd
pool_diffm <- function(mods_impdats,
                       n_imp,
                       analy) {

  purrr::map_dfr(n_imp, function(m) {
    estims <- mods_impdats[1:m] %$%
      summary(
        mice::pool(., dfcom = 999999), conf.int = T
      ) %>% 
      dplyr::rename(var = "term") %>% 
      dplyr::mutate(var = as.character(.data$var)) %>% 
      dplyr::mutate(m = m, 
                    analy = analy) %>% 
      dplyr::select(-.data$statistic, -.data$df)
  })
}


#' Pool for different m - for probabilities
#' 
#' @inheritParams pool_diffm
#' @param preds_impdats List of imputed datasets
#' 
#' @noRd
pool_diffm_preds <- function(preds_impdats,
                             n_imp,
                             analy) {
  
  
  
  pooled_preds <- purrr::map_dfr(n_imp, function(m) {
    
    # Take first m imputed datasets
    dplyr::bind_rows(preds_impdats[1:m], .id = "imp_num") %>% 
      
      # Make long format (pstate and true) to make pooling easier
      tidyr::pivot_longer(cols = .data$pstate1:.data$pstate3, 
                          names_to = "state_est", 
                          values_to = "prob") %>% 
      tidyr::pivot_longer(cols = .data$true_pstate2:.data$true_pstate1, 
                          names_to = "state_true", 
                          values_to = "true") %>% 
      
      # Make single state variable
      tidyr::unite( "state", 
                    .data$state_est, 
                    .data$state_true) %>% 
      dplyr::mutate(state = dplyr::case_when(
        stringr::str_detect(.data$state, "pstate1_true_pstate1") ~ "1",
        stringr::str_detect(.data$state, "pstate2_true_pstate2") ~ "2",
        stringr::str_detect(.data$state, "pstate3_true_pstate3") ~ "3"
      )) %>% 
      dplyr::filter(!is.na(.data$state)) %>% 
      tidyr::unite("combo-X_Z", .data$X, .data$Z, sep = "_X-Z_") %>% 
      
      # Rubins rules - only point estimate
      dplyr::group_by(.data$state, 
                      .data$`combo-X_Z`, 
                      .data$times, 
                      .data$true) %>% 
      
      # Pool on log scale here or not?
      dplyr::summarise(m = dplyr::n(),
                       p_pool = mean(.data$prob)) %>% 
      
      dplyr::mutate(analy = analy) %>% 
      dplyr::ungroup() %>% 
      
      # Add Squared error 
      dplyr::mutate(sq_err = (.data$p_pool - .data$true)^2)
  })
  
  return(pooled_preds)
}
