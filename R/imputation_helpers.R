##********************************##
## Helpers for Imputation methods ##
##********************************##


# MICE --------------------------------------------------------------------


get_predictor_mats <- function(dat) {
  
  #' Prepare prediction matrices MICE/smcfcs
  #' 
  #' @param dat Dataset as generated by generate_dat()
  #' 
  #' @return List of prediction matrices
  #' 
  #' @export
  
  mpred_ch1 <-  matrix(0, ncol(dat), ncol(dat),
                       dimnames = list(names(dat), 
                                       names(dat)))
  
  mpred_ch12 <- mpred_ch12_int <- mpred_smcfcs <- mpred_ch1 
  
  ## Ch1 model: MI with Z, eps (as factor) and H1(t) as covars
  mpred_ch1["X", c("Z", "ev1", "H1")] <- 1
  
  ## Ch12 model: MI with Z, eps, H1(t) & H2(t) as covars
  mpred_ch12["X", c("Z", "eps", "H1", "H2")] <- 1
  
  # Ch12 model with addition of interactions H x Z
  mpred_ch12_int["X", c("Z", "eps", "H1", "H2", "H1_Z", "H2_Z")] <- 1
  
  # smcfcs
  mpred_smcfcs["X", "Z"] <- 1
  
  # Store in a list
  mats <- list("CH1" = mpred_ch1, 
               "CH12" = mpred_ch12,
               "CH12_int" = mpred_ch12_int,
               "smcfcs" = mpred_smcfcs)
  
  return(mats)
}


get_imp_models <- function(dat) {
  
  #' Get vector of imputation models to use based on class of X
  #' 
  #' @param dat Dataset as generated by generate_dat()
  #' 
  #' @return Named character vector with methods to impute
  #' 
  #' @export
  
  methods <- character(ncol(dat))
  names(methods) <- colnames(dat)
  
  # Check if more than 3 unique vals (NA, 0, 1)\
  ifelse(is.factor(dat$X),
         methods["X"] <- "logreg",
         methods["X"] <- "norm")

  return(methods)
}


# Other -------------------------------------------------------------------


quiet <- function(expr) { 
  
  #' @title Silence function printing.
  #' 
  #' @description Takes a function/expression that by default uses 
  #' print() or cat(), and stops it. We use for MIcombine() or smcfc()
  #' 
  #' @param expr Expression to silence
  #' 
  #' 
  #' Source: http://r.789695.n4.nabble.com/Suppressing-output-e-g-from-cat-td859876.html

  sink(tempfile()) 
  on.exit(sink()) 
  invisible(force(expr)) 
} 



pool_diffm <- function(mods_impdats,
                       n_imp,
                       analy) {
  
  #' Pool for different m
  #' 
  #' @param mods_impdats complete
  #' @param n_imp Vector of m imputations to extract
  #' @param analy String label to attach
  #' 
  #' @importFrom magrittr `%$%` 
  #' 
  #' @export

  purrr::map_dfr(n_imp, function(m) {
    estims <- mods_impdats[1:m] %$%
      summary(
        mice::pool(., dfcom = 999999), conf.int = T
      ) %>% 
      dplyr::rename(var = "term") %>% 
      dplyr::mutate(var = as.character(.data$var)) %>% 
      dplyr::mutate(m = m, 
                    analy = analy) %>% 
      dplyr::select(-.data$statistic, -.data$df)
  })
}


summarise_ref_CCA <- function(mod,
                              analy) {
  
  #' Format CCA and ref analyses
  #' 
  #' @param mod Cause-specific model
  #' @inheritParams pool_diffm
  #' 
  #' @return Formatted df
  #' 
  #' @export

  summ_ref_CCA <- cbind(summary(mod)$coefficients,
        stats::confint(mod)) %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("var") %>% 
    dplyr::rename(estimate = .data$coef, 
                  std.error = .data$`se(coef)`,
                  p.value = .data$`Pr(>|z|)`) %>% 
    dplyr::select(-.data$`exp(coef)`, -.data$z) %>% 
    dplyr::mutate(m = 0, 
                  analy = analy)
  
  return(summ_ref_CCA)
}


record_warning <- function(expr) {
  
  #' Record rejection sampling failure smcfcs
  #' 
  #' @param expr Expression from which to record possible error
  #' 
  #' @return List with expression and associated warning
  #' 
  #' @export
  
  value <- withCallingHandlers(expr, 
                               warning = function(w) {
    warn <<- w
    invokeRestart("muffleWarning")
  })
  
  # Check if there was a warning at all
  ifelse(exists("warn"), 
         warn <- as.character(warn), 
         warn <- as.character(0))
  
  return(list(value = value, warning = warn))
}


pool_diffm_preds <- function(preds_impdats,
                             n_imp,
                             analy) {
  
  #' Pool for different m - with probabilities
  #' 
  #' @inheritParams pool_diffm
  #' @param preds_impdats List of lalala
  #' 
  #' @export
  
  pooled_preds <- purrr::map_dfr(n_imp, function(m) {
    
    # Take first m imputed datasets
    dplyr::bind_rows(preds_impdats[1:m], .id = "imp_num") %>% 
      
      # Make long format (pstate and true) to make pooling easier
      tidyr::pivot_longer(cols = .data$pstate1:.data$pstate3, 
                          names_to = "state_est", 
                          values_to = "prob") %>% 
      tidyr::pivot_longer(cols = .data$true_pstate2:.data$true_pstate1, 
                          names_to = "state_true", 
                          values_to = "true") %>% 
      
      # Make single state variable
      tidyr::unite( "state", 
                    .data$state_est, 
                    .data$state_true) %>% 
      dplyr::mutate(state = dplyr::case_when(
        stringr::str_detect(.data$state, "pstate1_true_pstate1") ~ "1",
        stringr::str_detect(.data$state, "pstate2_true_pstate2") ~ "2",
        stringr::str_detect(.data$state, "pstate3_true_pstate3") ~ "3"
      )) %>% 
      dplyr::filter(!is.na(.data$state)) %>% 
      tidyr::unite("combo-X_Z", .data$X, .data$Z, sep = "_X-Z_") %>% 
      
      # Rubins rules - only point estimate
      dplyr::group_by(.data$state, 
                      .data$`combo-X_Z`, 
                      .data$times, 
                      .data$true) %>% 
      
      # Pool on log scale here or not?
      dplyr::summarise(m = dplyr::n(),
                       p_pool = mean(.data$prob)) %>% 
      
      dplyr::mutate(analy = analy) %>% 
      dplyr::ungroup() %>% 
      
      # Add Squared error 
      dplyr::mutate(sq_err = (.data$p_pool - .data$true)^2)
  })
  
  return(pooled_preds)
}


preds_CCA_ref <- function(preds,
                          analy) {
  
  preds %>% 
    tidyr::pivot_longer(cols = .data$pstate1:.data$pstate3, 
                        names_to = "state_est", 
                        values_to = "prob") %>% 
    tidyr::pivot_longer(cols = .data$true_pstate2:.data$true_pstate1, 
                        names_to = "state_true", 
                        values_to = "true") %>% 
    
    # Make single state variable
    tidyr::unite( "state", 
                  .data$state_est, 
                  .data$state_true) %>% 
    dplyr::mutate(state = dplyr::case_when(
      stringr::str_detect(.data$state, "pstate1_true_pstate1") ~ "1",
      stringr::str_detect(.data$state, "pstate2_true_pstate2") ~ "2",
      stringr::str_detect(.data$state, "pstate3_true_pstate3") ~ "3"
    )) %>% 
    dplyr::filter(!is.na(.data$state)) %>% 
    tidyr::unite("combo-X_Z", .data$X, .data$Z, sep = "_X-Z_") %>% 
    
    # Labels
    dplyr::rename(p_pool = "prob") %>% 
    dplyr::mutate(analy = analy,
                  m = 0,
                  sq_err = (.data$p_pool - .data$true)^2)
  
}
