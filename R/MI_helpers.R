##********************************##
## Helpers for Imputation methods ##
##********************************##


# MICE --------------------------------------------------------------------


get_predictor_mats <- function(dat) {
  
  #' @title Prepare prediction matrices MICE/smcfcs
  #' 
  #' @param dat Dataset as generated by generate_dat()
  #' 
  #' @return List of prediction matrices
  
  mpred_ch1 <-  matrix(0, ncol(dat), ncol(dat),
                       dimnames = list(names(dat), 
                                       names(dat)))
  
  mpred_ch12 <- mpred_ch12_int <- mpred_ch1
  
  ## Ch1 model: MI with Z, eps (as factor) and H1(t) as covars
  mpred_ch1["X", c("Z", "ev1", "H1")] <- 1
  
  ## Ch12 model: MI with Z, eps, H1(t) & H2(t) as covars
  mpred_ch12["X", c("Z", "eps", "H1", "H2")] <- 1
  
  # Ch12 model with addition of interactions H x Z
  mpred_ch12_int["X", c("Z", "eps", "H1", "H2", "H1_Z", "H2_Z")] <- 1
  
  # Store in a list
  mats <- list("CH1" = mpred_ch1, "CH12" = mpred_ch12,
               "CH12_int" = mpred_ch12_int)
  
  return(mats)
}


get_imp_models <- function(dat) {
  
  #' @title Get vector of imputation models to use based on class of X
  #' 
  #' @param dat Dataset as generated by generate_dat()
  #' 
  #' @return Named character vector with methods to impute
  
  methods <- character(ncol(dat))
  names(methods) <- colnames(dat)
  
  # Check if more than 3 unique vals (NA, 0, 1)\
  ifelse(is.factor(dat$X),
         methods["X"] <- "logreg",
         methods["X"] <- "norm")

  return(methods)
}


# Other -------------------------------------------------------------------


quiet <- function(expr) { 
  
  #' @title Silence function printing.
  #' 
  #' @description Takes a function/expression that by default uses 
  #' print() or cat(), and stops it. We use for MIcombine() or smcfc()
  #' 
  #' @param expr Expression to silence
  #' 
  #' Source: http://r.789695.n4.nabble.com/Suppressing-output-e-g-from-cat-td859876.html

  sink(tempfile()) 
  on.exit(sink()) 
  invisible(force(expr)) 
} 



pool_diffm <- function(mods_impdats,
                       n_imp,
                       analy) {
  
  #' @title Pool for different m
  #' 
  #' @param mods_impdats complete
  #' @param n_imp Vector of m imputations to extract
  #' @param analy String label to attach
  #' 
  #' @importFrom tibble rownames_to_column
  #' @importFrom mice pool mice
  #' @importFrom smcfcs smcfcs
  #' @importFrom JointAI coxph_imp MC_error traceplot
  #' @importFrom magrittr `%$%` 
  #' 
  #' @export
  
  purrr::map_dfr(n_imp, function(m) {
    estims <- mods_impdats[1:m] %$%
      summary(pool(., dfcom = 999999), conf.int = T) %>% 
      tibble::rownames_to_column(var = "var") %>% 
      mutate(
        m = m, 
        analy = analy,
        rej = .data$p.value < 0.05
      ) %>% 
      select(-.data$statistic, -.data$df)
  })
}


summarise_bayes <- function(mod) {
  
  #' @title Format JointAI output for sim summary
  #' 
  #' @param mod JointAI model
  #' 
  #' @return Formatted data.frame

  summary(mod)$stats %>% 
    as.data.frame() %>% 
    mutate(var = c("X.1", "Z.1"),
           analy = "JointAI",
           m = summary(mod)$size) %>% 
    rename(estimate = .data$Mean, std.error = .data$SD,
           `2.5 %` = `2.5%`, `97.5 %` = `97.5%`) %>% 
    select(-.data$`GR-crit`, -.data$`tail-prob.`)
}


summarise_ref_CCA <- function(mod,
                              analy) {
  
  #' @title Format CCA and ref analyses
  #' 
  #' @param mod Cause-specific model
  #' @inheritParams pool_diffm
  #' 
  #' @return Formatted df

  cbind(summary(mod)$coefficients,
        confint(mod)) %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column("var") %>% 
    rename(estimate = .data$coef, 
           std.error = .data$`se(coef)`,
           p.value = .data$`Pr(>|z|)`) %>% 
    select(-.data$`exp(coef)`, -.data$z) %>% 
    mutate(m = 0, 
           analy = analy,
           rej =.data$p.value < 0.05)  
}


record_warning <- function(expr) {
  
  #' @title Record rejection sampling failure smcfcs
  #' 
  #' @param expr Expression from which to record possible error
  #' 
  #' @return List with expression and associated warning
  
  value <- withCallingHandlers(expr, 
                               warning = function(w) {
    warn <<- w
    invokeRestart("muffleWarning")
  })
  
  # Check if there was a warning at all
  ifelse(exists("warn"), warn <- as.character(warn), warn <- as.character(0))
  list(value = value, warning = warn)
}




pool_diffm_preds <- function(preds_impdats,
                             n_imp,
                             analy) {
  
  #' @title Pool for different m - with probabilities
  #' 
  #' @inheritParams pool_diffm
  #' @param preds_impdats List of lalala
  #' 
  #' @export
  
  purrr::map_dfr(n_imp, function(m) {
    bind_rows(preds_impdats[1:m], .id = "imp_num") %>% 
      gather(state_est, prob, pstate1:pstate3) %>% 
      gather(state_SE, se, se1:se3) %>% 
      gather(state_true, true, true_pstate2:true_pstate1) %>% 
      unite(state, state_est, state_SE, state_true) %>% 
      mutate(state = case_when(
        str_detect(state, "pstate1_se1_true_pstate1") ~ "1",
        str_detect(state, "pstate2_se2_true_pstate2") ~ "2",
        str_detect(state, "pstate3_se3_true_pstate3") ~ "3"
      )) %>% 
      filter(!is.na(state)) %>% 
      unite("combo-X_Z", X, Z, sep = "_X-Z_") %>% 
      
      # Rubins rules here
      group_by(state, `combo-X_Z`, times, true) %>% 
      
      # Pool on log scale here or not?
      summarise(
        m = dplyr::n(),
        p_pool = mean(.data$prob),
        w_bar = mean(.data$se^2),
        b_bar = var(.data$prob),
        t = .data$w_bar + (1 + .data$m^(-1)) * .data$b_bar,
        se_pool = sqrt(t)
      ) %>% 
      select(-.data$w_bar, -.data$b_bar, -.data$t) %>% 
      
      # Add confidence intervals on log scale
      mutate(
        low = exp(log(p_pool) - qnorm(0.975) * se_pool / p_pool),
        #low = p_pool - qnorm(0.975) * se_pool,
        low = ifelse(low < 0, 0, low),
        upp = exp(log(p_pool) + qnorm(0.975) * se_pool / p_pool),
        #upp = p_pool + qnorm(0.975) * se_pool,
        upp = ifelse(upp > 1, 1, upp)
      ) %>% 
      mutate(analy = analy) %>% 
      ungroup() %>% 
      
      # Add Squared error 
      mutate(sq_err = (p_pool - true)^2)
  })
}

