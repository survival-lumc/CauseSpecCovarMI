##********************************##
## Helpers for Imputation methods ##
##********************************##



# MICE --------------------------------------------------------------------



get_predictor_mats <- function(.data) {
  
  #' @title Prepare prediction matrices MICE/smcfcs
  #' 
  #' @param .data Dataset as generated by generate_dat()
  #' 
  #' @return List of prediction matrices
  
  mpred_ch1 <-  matrix(0, ncol(.data), ncol(.data),
                       dimnames = list(names(.data), 
                                       names(.data)))
  
  mpred_ch12 <- mpred_ch12_int <- mpred_ch1
  
  ## Ch1 model: MI with Z, eps (as factor) and H1(t) as covars
  mpred_ch1["X", c("Z", "ev1", "H1")] <- 1
  
  ## Ch12 model: MI with Z, eps, H1(t) & H2(t) as covars
  mpred_ch12["X", c("Z", "eps", "H1", "H2")] <- 1
  
  # Ch12 model with addition of interactions H x Z
  mpred_ch12_int["X", c("Z", "eps", "H1", "H2", "H1_Z", "H2_Z")] <- 1
  
  # Store in a list
  mats <- list("CH1" = mpred_ch1, "CH12" = mpred_ch12,
               "CH12_int" = mpred_ch12_int)
  
  return(mats)
}


get_imp_models <- function(.data) {
  
  #' @title Get vector of imputation models to use based on class of X
  #' 
  #' @param .data Dataset as generated by generate_dat()
  #' 
  #' @return Named character vector with methods to impute
  
  methods <- character(ncol(.data))
  names(methods) <- colnames(.data)
  
  # Check if more than 3 unique vals (NA, 0, 1)\
  ifelse(is.factor(.data$X),
         methods["X"] <- "logreg",
         methods["X"] <- "norm")

  return(methods)
}



mice_pool_diffm <- function(imps, # output of mice()
                            m, # vector of no. imputed datasets eg. c(1, 5, 10)
                            label) { # character vector labeling current analysis
  
  #' @title Pool different m mice
  #' 
  #' @description Takes a mice() object with m imputations eg. 100
  #' 
  #' @param label Label of analysis type
  #' @param m vector c(5, 10, 25)
  #' 
  #' @return Returns pooled estimates for biggest m and others.
  
  # Iterate procedure for all vals of m                     
  ests <- lapply(m, function(i) { # change indicator i later
    
    # Change the imp object so as to subsets first i imputations
    imps$m <- i
    
    # Have to use select() here, cannot use []
    imps$imp <- lapply(imps$imp, function(x) x %>% select(1:i))
    
    # Analyse and pool as usual 
    result <- with(imps, coxph(Surv(t, eps == 1) ~ X1 + X2))
    pooled <- suppressWarnings(summary(pool(result), conf.int = T)) 
    
    # If single imputation, selection is slightly different
    if (i == 1) {
      
      summ <- pooled$coefficients[, c("coef", "se(coef)", "Pr(>|z|)")]
      pooled <- cbind.data.frame(summ, confint(result$analyses[[1]])) %>%
        select(coef, se = "se(coef)", pval = "Pr(>|z|)", `2.5 %`, `97.5 %`)
      
      # Single imputation so sd over imputations == 0
      #sd_imps <- rep(0, 2)
    } else {
      
      # Keep relevant estimates
      pooled <- as.data.frame(pooled) %>%
        select(coef = estimate, se = std.error, pval = p.value, `2.5 %`, `97.5 %`)
      
      # Compute sd of estimates across imputations
      #sd_imps <- apply(sapply(result$analyses, coefficients), 1, sd)
    }
    
    # Append all 
    pooled <- pooled %>%
      mutate(var = c("X1", "X2"), m = i,
             analy = label, true = true_betas)
    
    return(pooled)
  })
  
  return(bind_rows(ests))
} 




# smcfcs ------------------------------------------------------------------



smcfcs_pool_diffm <- function(imps, # output of smcfcs()
                              m, # vector of no. imputed datasets eg. c(1, 5, 10)
                              label) { # character vector labeling current analysis
  
  
  #' @title Pool different m smcfcs
  #' 
  #' @description Takes a smcfcs() object with m imputations eg. 100
  #' call source("quiet_printcat.R") if used on its own
  #' 
  #' @param label Label of analysis type
  #' @param m vector c(5, 10, 25)
  #' 
  #' @return Returns pooled estimates for biggest m

  
  # Make list out of imputations
  impobj <- imputationList(imps$impDatasets)
  
  # Iterate procedure for all vals of m                     
  ests <- lapply(m, function(i) { # change indicator i later
    
    # Select first m imputed datasets
    if (i == 1) {
      impobj$imputations <- impobj$imputations[i]
      result <- with(impobj, coxph(Surv(t, eps == 1) ~ X1 + X2))[[1]]
      summ <- summary(result)$coefficients[, c("coef", "se(coef)", "Pr(>|z|)")]
      
      # Format
      pooled <- cbind.data.frame(summ, confint(result)) %>%
        select(coef, se = "se(coef)", pval = "Pr(>|z|)", `2.5 %`, `97.5 %`)
      
    } else {
      impobj$imputations <- impobj$imputations[1:i]
      
      # Analyse and pool as usual 
      models <- with(impobj, coxph(Surv(t, eps == 1) ~ X1 + X2))
      summ <- quiet(summary(MIcombine(models)))
      
      # Summarise, add pva;
      pooled <-  summ %>% 
        mutate(z = results / se,
               pval = 2 * pnorm(abs(z), lower.tail = F)) %>%
        select(coef = results, se, pval, 
               `2.5 %` = `(lower`, `97.5 %` = `upper)`)
      
    }
    
    pooled <- pooled %>% 
      mutate(var = c("X1", "X2"), m = i, 
             analy = label, true = true_betas)
    
    return(pooled)
  })
  
  return(bind_rows(ests))
} 




# Other -------------------------------------------------------------------




quiet <- function(x) { 
  
  #' @title Silence function printing.
  #' 
  #' @description Takes a function/expression that by default uses 
  #' print() or cat(), and stops it. We use for MIcombine() or smcfc()
  #' 
  #' Source: http://r.789695.n4.nabble.com/Suppressing-output-e-g-from-cat-td859876.html
  sink(tempfile()) 
  on.exit(sink()) 
  invisible(force(x)) 
} 
